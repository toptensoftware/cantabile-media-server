<html>
<head>
<meta charset="utf-8">
<style>
:root
{
    color-scheme: dark;
    font-family: sans-serif;
}
body
{
    margin: 0;
}

#mediaContainer
{
    width: 640px; 
    height: 480px;
}

.mediaElement
{
    width: 100%; 
    height: 100%;
    background-color: black;
}

img.mediaElement
{
    object-fit: contain;
}

</style>
<script src="webrtc_video_stream.js"></script>
</head>
<body>
    <div id="mediaContainer">
        <!-- media elements will be inserted here -->
    </div>
    <div id="controls">
        Channel:
        <select id="channel">
            <option value="0">1</option>
            <option value="1">2</option>
            <option value="2">3</option>
            <option value="3">4</option>
            <option value="4">5</option>
            <option value="5">6</option>
            <option value="6">7</option>
            <option value="7">8</option>
            <option value="8">9</option>
            <option value="9">10</option>
            <option value="10">11</option>
            <option value="11">12</option>
            <option value="12">13</option>
            <option value="13">14</option>
            <option value="14">15</option>
            <option value="15">16</option>
        </select>
        <button id="btnFullScreen">Full-Screen</button>
    </div>
</div>


<script type="module">

import { WHEPClient } from "/whip-whep/whep.js";

// In edge/chrome -> settings -> media autoplay -> allow -> add site, or turn off limiting globally.

// State
let mediaController = null;
let activeChannel = -1;
let channelState = null;

// Get element
let selChannel = document.getElementById("channel");

// Full-screen button handler
document.getElementById("btnFullScreen").onclick = (event) => {
    document.getElementById("mediaContainer").requestFullscreen();
}

// URL Hash <-> Channel selector
if (document.location.hash.length > 1)
{
    hashChanged();
}
else
{
    loadChannel();
}
window.addEventListener("hashchange", hashChanged);
selChannel.onchange = () => {
    document.location.hash = `#ch=${parseInt(selChannel.value) + 1}`;
    loadChannel();
}
function hashChanged()
{
    var state = new URLSearchParams('?' + document.location.hash.substring(1));
    if (state.get("ch"))
    {
        selChannel.value = parseInt(state.get("ch") - 1);
    }
    loadChannel();
    
}


// Channel Load

async function loadChannel()
{
    // Get currently selected channel
    let channel = parseInt(selChannel.value);
    if (channel == activeChannel || channel < 0 || channel > 15)
        return;

    // Store active channel (to prevent duplicate requests)
    activeChannel = channel;

    // Clear channel state until retrieved
    channelState = null;

    // Get the current channel state from server
    let response = await fetch(`/channelState/${channel}`);
    channelState = await response.json();

    onChannelStateChanged();
}

function onChannelStateChanged()
{
    // Store old media controller
    let oldMediaController = mediaController;
    mediaController = null;

    // Create new media controller
    if (channelState.mediaFile?.startsWith("webrtc+"))
    {
        mediaController = webrtcMediaController(channelState);
    }
    else if (channelState.mimeType.startsWith("video/"))
    {
        mediaController = videoMediaController(channelState);
    }
    else if (channelState.mimeType.startsWith("image/"))
    {
        mediaController = imageMediaController(channelState);
    }

    // Insert media element into document
    if (mediaController != null)
        document.getElementById("mediaContainer").appendChild(mediaController.element);

    // Remove old media
    oldMediaController?.close();
}

// WebSocket handler
let ws = new WebSocket(((window.location.protocol === "https:") ? "wss://" : "ws://") + window.location.host + "/ws");
ws.onmessage = (event) => {
    var msg = JSON.parse(event.data);
    console.log(msg);

    // Check message is for correct channel (or -1 for "all channels")
    if (channelState == null || (msg.channel != activeChannel && msg.channel != -1))
        return;

    switch (msg.action)
    {
        case 'play':
            mediaController.play?.();
            break;

        case 'pause':
            mediaController.pause?.(msg.currentTime);
            break;

        case 'stop':
            mediaController.stop?.();
            break;

        case 'load':
            channelState = msg.channelState;
            onChannelStateChanged();
            break;
    }
};

function imageMediaController(mediaFile)
{
    let element = document.createElement("img");
    element.classList.add("mediaElement");
    element.setAttribute('src', channelState.mediaFile);

    return {
        close: () => element.remove(),
        element, 
    }
}

function videoMediaController(channelState)
{

    let element = document.createElement("video");
    element.classList.add("mediaElement");
    element.setAttribute('src', channelState.mediaFile);
    element.muted = true;
    element.currentTime = channelState.currentTime;

    return {
        close: () => { element.pause(); element.remove(); },
        play: () => element.play(),
        pause: (position) => { element.pause(); element.currentTime = position; },
        stop: () => { element.pause(); element.currentTime = 0; },
        element, 
    }
}

function webrtcMediaController(channelState)
{
    let whep_url = channelState.mediaFile.substring("webrtc+".length);

    // Create element
    let element = document.createElement("video");
    element.classList.add("mediaElement");
    element.muted = true;

    // Setup RTC connection
    const pc = window.pc = new RTCPeerConnection({ bundlePolicy: "max-bundle" });
    pc.addTransceiver("audio");
    pc.addTransceiver("video");
    pc.ontrack = (event) =>
    {
        if (event.track.kind == "video")
        {
            element.srcObject = event.streams[0];
            element.play();
        }
    }

    //Create whep client
    const whep = new WHEPClient();
    whep.view(pc, whep_url);

    return {
        close: () => {
            element.pause(0);
            whep.stop();
            element.remove();
        },
        element,
    }
}

</script>

</body>
</html>