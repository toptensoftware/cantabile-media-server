<html>
<head>
<meta charset="utf-8">
<style>
:root
{
    color-scheme: dark;
    font-family: sans-serif;
}
body
{
    margin: 0;
}

#mediaContainer
{
    width: 640px; 
    height: 480px;
}

.mediaElement
{
    width: 100%; 
    height: 100%;
    background-color: black;
}

img.mediaElement
{
    object-fit: contain;
}

#latcomp
{
    width: 60px;
}

</style>
</head>
<body>
    <div id="mediaContainer">
        <!-- media elements will be inserted here -->
    </div>
    <div id="controls">
        Channel:
        <select id="channel">
            <option value="0">1</option>
            <option value="1">2</option>
            <option value="2">3</option>
            <option value="3">4</option>
            <option value="4">5</option>
            <option value="5">6</option>
            <option value="6">7</option>
            <option value="7">8</option>
            <option value="8">9</option>
            <option value="9">10</option>
            <option value="10">11</option>
            <option value="11">12</option>
            <option value="12">13</option>
            <option value="13">14</option>
            <option value="14">15</option>
            <option value="15">16</option>
        </select>
        Latency Compensation:
        <input id="latcomp" type="number" value="0"/>
        ms.
        <button id="btnFullScreen">Full-Screen</button>
        <span id="rate"></span>
    </div>
</div>


<script type="module">

import { WHEPClient } from "/whip-whep/whep.js";

// In edge/chrome -> settings -> media autoplay -> allow -> add site, or turn off limiting globally.

// State
let mediaController = null;
let activeChannel = -1;
let channelState = null;
let socketOpen = false;
let embed = null;

// Get element
let selChannel = document.getElementById("channel");
let latcomp = document.getElementById("latcomp");
let elRate = document.getElementById("rate");

// Full-screen button handler
document.getElementById("btnFullScreen").onclick = (event) => {
    //document.getElementById("mediaContainer").requestFullscreen();
    embed.contentWindow.scrollTo(0, 1000);
}

// URL Hash <-> Channel selector
if (document.location.hash.length > 1)
{
    hashChanged();
}
else
{
    loadChannel();
}
window.addEventListener("hashchange", hashChanged);
selChannel.onchange = () => {
    updateHash();
    loadChannel();
}

latcomp.oninput = updateHash;

function updateHash()
{
    let parts = [];
    if (selChannel.value != 0)
        parts.push(`ch=${parseInt(selChannel.value) + 1}`);
    if (latcomp.value != 0)
        parts.push(`latcomp=${latcomp.value}`);

    if (parts.length == 0)
        document.location.hash = "";
    else
        document.location.hash = `#${parts.join('&')}`;
}

function hashChanged()
{
    var state = new URLSearchParams('?' + document.location.hash.substring(1));
    if (state.get("ch"))
    {
        selChannel.value = parseInt(state.get("ch") - 1);
    }
    if (state.get("latcomp"))
    {
        latcomp.value = parseInt(state.get("latcomp"));
    }
    loadChannel();
}


// Channel Load

async function loadChannel()
{
    // Quit if socket not yet open
    if (!socketOpen)
        return;

    // Get currently selected channel
    let channel = parseInt(selChannel.value);
    if (channel == activeChannel || channel < 0 || channel > 15)
        return;

    // Store active channel (to prevent duplicate requests)
    activeChannel = channel;

    // Clear channel state until retrieved
    channelState = null;

    // Send command requesting state of active channel
    ws.send(JSON.stringify({ 
        action: "setChannelMask", 
        channelMask: 1 << activeChannel
    }));
}

function onChannelStateChanged()
{
    // Store old media controller
    let oldMediaController = mediaController;
    mediaController = null;

    if (channelState != null)
    {
        // Create new media controller
        if (channelState.mediaFile?.startsWith("webrtc+"))
        {
            mediaController = webrtcMediaController(channelState);
        }
        else if (channelState.mimeType.startsWith("video/"))
        {
            mediaController = videoMediaController(channelState);
        }
        else if (channelState.mimeType.startsWith("image/"))
        {
            mediaController = imageMediaController(channelState);
        }
        else if (channelState.mimeType == "application/pdf")
        {
            mediaController = pdfMediaController(channelState);
        }
    }

    // Insert media element into document
    if (mediaController != null)
        document.getElementById("mediaContainer").appendChild(mediaController.element);

    // Remove old media
    oldMediaController?.close();
}

// WebSocket handler
let ws = new WebSocket(((window.location.protocol === "https:") ? "wss://" : "ws://") + window.location.host + "/ws");
ws.onopen = (event) => {
    socketOpen = true;
    loadChannel();
};
ws.onclose = (event) => {
    channelState = null;
    onChannelStateChanged();
    socketOpen = false;
};
ws.onmessage = (event) => {
    var msg = JSON.parse(event.data);

    switch (msg.action)
    {
        case 'channelStates':
            channelState = msg.channelStates[activeChannel] ?? null;
            onChannelStateChanged();
            break;
            
        case 'sync':
            if (msg.timestamps[activeChannel] !== undefined)
            {
                mediaController.sync?.(msg.timestamps[activeChannel]);
            }
            break;
    }


    // Check message is for correct channel (or -1 for "all channels")
    if (channelState == null || (msg.channel != activeChannel && msg.channel != -1))
        return;

    switch (msg.action)
    {
        case 'play':
            mediaController.play?.();
            break;

        case 'pause':
            mediaController.pause?.(msg.currentTime);
            break;

        case 'stop':
            mediaController.stop?.();
            break;

        case 'load':
            channelState = msg.channelState;
            onChannelStateChanged();
            break;
    }
};

function imageMediaController(mediaFile)
{
    let element = document.createElement("img");
    element.classList.add("mediaElement");
    element.setAttribute('src', channelState.mediaFile);

    return {
        close: () => element.remove(),
        element, 
    }
}

function videoMediaController(channelState)
{

    let element = document.createElement("video");
    element.classList.add("mediaElement");
    element.setAttribute('src', channelState.mediaFile);
    element.muted = true;
    element.currentTime = channelState.currentTime;
//    element.playbackRate = 2;

    let playStartBaseTime = null;
    let playStartVideoTime = null;
    let currentLatComp = 0;

    function play()
    {
        currentLatComp = latcomp.value / 1000.0;
        element.currentTime += currentLatComp;
        playStartBaseTime = Date.now();
        playStartVideoTime = element.currentTime;
        element.play();
    }

    function pause(timestamp)
    {
        playStartBaseTime = null;
        playStartVideoTime = null;
        element.pause(); 
        element.currentTime = timestamp;
        elRate.innerText = "";
    }

    function stop()
    {
        pause(0);
    }

    function sync(timestamp)
    {
        // Quit if we don't have a base time
        if (playStartBaseTime == null)
            return;

        // Latency compensation
        timestamp += currentLatComp;

        // Get current video position
        let videoPos = element.currentTime;

        // If more than 1 second out of sync, resync immediately
        if (Math.abs(videoPos - timestamp) > 1)
        {
            //console.log("full resync");
            element.currentTime = timestamp;
            playStartBaseTime = Date.now();
            playStartVideoTime = timestamp;
            return;
        }   

        // Calculate new rate by comparing server elapsed time to our elapsed time
        // and calculating an adjustment rate.
        let localElapsed = (Date.now() - playStartBaseTime) / 1000.0;
        let serverElapsed = timestamp - playStartVideoTime;
        let rate = serverElapsed / localElapsed;

        // Also, if we're ahead or behind, calculate a "catch up" factor that should
        // gradually pull us closer to the target time stamp
        let catchup = (videoPos - timestamp) / 2;

        //console.log(`server:${timestamp} el: ${videoPos} s_elap:${serverElapsed} l_elap:${localElapsed} rate:${rate} catchup:${catchup}`);
        //console.log(`rate:${rate - catchup} delta:${timestamp - videoPos}`);

        try
        {
            // Set video playback rate
            element.playbackRate = rate - catchup;
        }
        catch
        {
            //console.log("full resync due to error");
            element.currentTime = timestamp;
            playStartBaseTime = Date.now();
            playStartVideoTime = timestamp;
        }

        elRate.innerText = `Rate: x${element.playbackRate.toFixed(3)}`;
    }

    return {
        close: () => { element.pause(); element.remove(); },
        play,
        pause,
        stop,
        sync,
        element, 
    }
}

function webrtcMediaController(channelState)
{
    let whep_url = channelState.mediaFile.substring("webrtc+".length);

    // Create element
    let element = document.createElement("video");
    element.classList.add("mediaElement");
    element.muted = true;

    // Setup RTC connection
    const pc = window.pc = new RTCPeerConnection({ bundlePolicy: "max-bundle" });
    pc.addTransceiver("audio");
    pc.addTransceiver("video");
    pc.ontrack = (event) =>
    {
        if (event.track.kind == "video")
        {
            element.srcObject = event.streams[0];
            element.play();
        }
    }

    //Create whep client
    const whep = new WHEPClient();
    whep.view(pc, whep_url);

    return {
        close: () => {
            element.pause(0);
            whep.stop();
            element.remove();
        },
        element,
    }
}

function pdfMediaController(mediaFile)
{
    let element = document.createElement("iframe");
    element.classList.add("mediaElement");
//    element.setAttribute("type", "application/pdf");
    element.setAttribute('src', channelState.mediaFile + "#toolbar=0&navpanes=0&scrollbar=0");
    embed = element;
    return {
        close: () => element.remove(),
        element, 
    }
}



</script>

</body>
</html>