<html>
<head>
<meta charset="utf-8">
<style>
:root
{
    color-scheme: dark;
    font-family: sans-serif;
}
body
{
    margin: 0;
}

#mediaContainer
{
    position: relative;
    width: 640px; 
    height: 480px;
}

.mediaElement
{
    position: absolute;
    top: 0;
    left: 0;    
    width: 100%; 
    height: 100%;
    background-color: black;
}

img.mediaElement
{
    object-fit: contain;
}

#latcomp
{
    width: 60px;
}

</style>
</head>
<body>
    <div id="mediaContainer">
        <!-- media elements will be inserted here -->
    </div>
    <div id="controls">
        Channel:
        <select id="channel">
            <option value="0">1</option>
            <option value="1">2</option>
            <option value="2">3</option>
            <option value="3">4</option>
            <option value="4">5</option>
            <option value="5">6</option>
            <option value="6">7</option>
            <option value="7">8</option>
            <option value="8">9</option>
            <option value="9">10</option>
            <option value="10">11</option>
            <option value="11">12</option>
            <option value="12">13</option>
            <option value="13">14</option>
            <option value="14">15</option>
            <option value="15">16</option>
        </select>
        Latency Compensation:
        <input id="latcomp" type="number" value="0"/>
        ms.
        <button id="btnFullScreen">Full-Screen</button>
        <span id="rate"></span>
    </div>
</div>


<script type="module">

import { WHEPClient } from "/whip-whep/whep.js";

// In edge/chrome -> settings -> media autoplay -> allow -> add site, or turn off limiting globally.

// State
let layerControllers = [];
let activeChannel = -1;
let channelState = null;
let socketOpen = false;

// Get element
let selChannel = document.getElementById("channel");
let latcomp = document.getElementById("latcomp");
let elRate = document.getElementById("rate");

// Full-screen button handler
document.getElementById("btnFullScreen").onclick = (event) => {
    document.getElementById("mediaContainer").requestFullscreen();
}

// URL Hash <-> Channel selector
if (document.location.hash.length > 1)
{
    hashChanged();
}
else
{
    loadChannel();
}
window.addEventListener("hashchange", hashChanged);
selChannel.onchange = () => {
    updateHash();
    loadChannel();
}

latcomp.oninput = updateHash;

function updateHash()
{
    let parts = [];
    if (selChannel.value != 0)
        parts.push(`ch=${parseInt(selChannel.value) + 1}`);
    if (latcomp.value != 0)
        parts.push(`latcomp=${latcomp.value}`);

    if (parts.length == 0)
        document.location.hash = "";
    else
        document.location.hash = `#${parts.join('&')}`;
}

function hashChanged()
{
    var state = new URLSearchParams('?' + document.location.hash.substring(1));
    if (state.get("ch"))
    {
        selChannel.value = parseInt(state.get("ch") - 1);
    }
    if (state.get("latcomp"))
    {
        latcomp.value = parseInt(state.get("latcomp"));
    }
    loadChannel();
}


// Channel Load

async function loadChannel()
{
    // Quit if socket not yet open
    if (!socketOpen)
        return;

    // Get currently selected channel
    let channel = parseInt(selChannel.value);
    if (channel == activeChannel || channel < 0 || channel > 15)
        return;

    // Store active channel (to prevent duplicate requests)
    activeChannel = channel;

    // Clear channel state until retrieved
    channelState = null;

    // Send command requesting state of active channel
    ws.send(JSON.stringify({ 
        action: "setChannel", 
        channel: activeChannel
    }));
}

function onLoadChannel(cs)
{
    // Store new channel state
    channelState = cs;

    // Close old layer controllers
    layerControllers.forEach(x => x.close());
    layerControllers = [];

    if (channelState != null)
    {
        // Allocate array to hold layer controllers
        for (let i=0; i<cs.layers.length; i++)
        {
            layerControllers.push(null);
            onLoadLayer(i, cs.layers[i]);
        }
    }
}

function onLoadLayer(index, ls)
{
    // Create new media controller
    let layerController;
    if (ls.mediaFile)
    {
        if (ls.mediaFile?.startsWith("webrtc+"))
        {
            layerController = webrtcLayerController(ls);
        }
        else if (ls.mimeType.startsWith("video/"))
        {
            layerController = videoLayerController(ls);
        }
        else if (ls.mimeType.startsWith("image/"))
        {
            layerController = imageLayerController(ls);
        }
        /*
        else if (ls.mimeType == "application/pdf")
        {
            layerController = pdfLayerController(ls);
        }
        */
    }
    if (layerController == null)
    {
        layerController = nullLayerController(index);
    }

    // Replace or append
    if (layerControllers[index])
    {
        layerControllers[index].element.replaceWith(layerController.element);
        layerControllers[index].close();
    }
    else
    {
        document.getElementById("mediaContainer").appendChild(layerController.element);
    }

    // Store new media controller
    layerControllers[index] = layerController;
}

// WebSocket handler
let ws = new WebSocket(((window.location.protocol === "https:") ? "wss://" : "ws://") + window.location.host + "/ws");
ws.onopen = (event) => {
    socketOpen = true;
    loadChannel();
};
ws.onclose = (event) => {
    onLoadChannel(null);
    socketOpen = false;
};
ws.onmessage = (event) => {
    var msg = JSON.parse(event.data);

    switch (msg.action)
    {
        case 'sync':
            for (let ts of msg.timestamps)
            {
                if (ts.channel == activeChannel)
                {
                    layerControllers[ts.layer].sync?.(ts.timestamp);
                }
            }
            break;

        case 'loadChannel':
            onLoadChannel(msg.channelState ?? null);
            break;
    }


    // Check message is for correct channel (or -1 for "all channels")
    if (channelState == null || (msg.channel != activeChannel && msg.channel != -1))
        return;

    switch (msg.action)
    {
        case 'play':
            layerControllers[msg.layer].play?.();
            break;

        case 'pause':
            layerControllers[msg.layer].pause?.(msg.currentTime);
            break;

        case 'stop':
            layerControllers[msg.layer].stop?.();
            break;

        case 'loadLayer':
            onLoadLayer(msg.layer, msg.layerState);
            break;
    }
};

function nullLayerController(index)
{
    let element = document.createComment(`null layer (${index})`);
    return {
        close: () => element.remove(),
        element, 
    }
}

function imageLayerController(layer)
{
    let element = document.createElement("img");
    element.classList.add("mediaElement");
    element.setAttribute('src', layer.mediaFile);

    return {
        close: () => element.remove(),
        element, 
    }
}

function videoLayerController(layer)
{

    let element = document.createElement("video");
    element.classList.add("mediaElement");
    element.setAttribute('src', layer.mediaFile);
    element.muted = true;
    element.currentTime = layer.currentTime;
//    element.playbackRate = 2;

    let playStartBaseTime = null;
    let playStartVideoTime = null;
    let currentLatComp = 0;

    function play()
    {
        currentLatComp = latcomp.value / 1000.0;
        element.currentTime += currentLatComp;
        playStartBaseTime = Date.now();
        playStartVideoTime = element.currentTime;
        element.play();
    }

    function pause(timestamp)
    {
        playStartBaseTime = null;
        playStartVideoTime = null;
        element.pause(); 
        element.currentTime = timestamp;
        elRate.innerText = "";
    }

    function stop()
    {
        pause(0);
    }

    function sync(timestamp)
    {
        // Quit if we don't have a base time
        if (playStartBaseTime == null)
            return;

        // Latency compensation
        timestamp += currentLatComp;

        // Get current video position
        let videoPos = element.currentTime;

        // If more than 1 second out of sync, resync immediately
        if (Math.abs(videoPos - timestamp) > 1)
        {
            //console.log("full resync");
            element.currentTime = timestamp;
            playStartBaseTime = Date.now();
            playStartVideoTime = timestamp;
            return;
        }   

        // Calculate new rate by comparing server elapsed time to our elapsed time
        // and calculating an adjustment rate.
        let localElapsed = (Date.now() - playStartBaseTime) / 1000.0;
        let serverElapsed = timestamp - playStartVideoTime;
        let rate = serverElapsed / localElapsed;

        // Also, if we're ahead or behind, calculate a "catch up" factor that should
        // gradually pull us closer to the target time stamp
        let catchup = (videoPos - timestamp) / 2;

        //console.log(`server:${timestamp} el: ${videoPos} s_elap:${serverElapsed} l_elap:${localElapsed} rate:${rate} catchup:${catchup}`);
        //console.log(`rate:${rate - catchup} delta:${timestamp - videoPos}`);

        try
        {
            // Set video playback rate
            element.playbackRate = rate - catchup;
        }
        catch
        {
            //console.log("full resync due to error");
            element.currentTime = timestamp;
            playStartBaseTime = Date.now();
            playStartVideoTime = timestamp;
        }

        elRate.innerText = `Rate: x${element.playbackRate.toFixed(3)}`;
    }

    return {
        close: () => { element.pause(); element.remove(); },
        play,
        pause,
        stop,
        sync,
        element, 
    }
}

function webrtcLayerController(layer)
{
    let whep_url = layer.mediaFile.substring("webrtc+".length);

    // Create element
    let element = document.createElement("video");
    element.classList.add("mediaElement");
    element.muted = true;

    // Setup RTC connection
    const pc = window.pc = new RTCPeerConnection({ bundlePolicy: "max-bundle" });
    pc.addTransceiver("audio");
    pc.addTransceiver("video");
    pc.ontrack = (event) =>
    {
        if (event.track.kind == "video")
        {
            element.srcObject = event.streams[0];
            element.play();
        }
    }

    //Create whep client
    const whep = new WHEPClient();
    whep.view(pc, whep_url);

    return {
        close: () => {
            element.pause(0);
            whep.stop();
            element.remove();
        },
        element,
    }
}

/*
function pdfLayerController(mediaFile)
{
    let element = document.createElement("iframe");
    element.classList.add("mediaElement");
//    element.setAttribute("type", "application/pdf");
    element.setAttribute('src', channelState.mediaFile + "#toolbar=0&navpanes=0&scrollbar=0");
    embed = element;
    return {
        close: () => element.remove(),
        element, 
    }
}
    */



</script>

</body>
</html>